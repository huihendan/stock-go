# 回测策略系统重构方案

## 一、当前问题分析

### 1.1 主要问题

1. **策略职责不清晰**: 现有策略既要负责选股，又要负责买卖信号，职责混乱
2. **未来函数问题**: 策略2/3使用`findSellPriceOptimized()`存在严重的未来函数问题
3. **卖出逻辑缺失**: 新策略1的`DealStrategySell()`是空实现
4. **选股和交易未分离**: 没有明确的选股器(Stock Selector)概念

### 1.2 现有代码结构

```
/home/beven/gits/stock-go/
├── globalDefine/              # 全局配置
│   ├── globalConfig.go        # 配置常量和路径设置
│   └── wallet.go              # 钱包、持仓、操作记录结构
├── stockData/                 # 数据处理核心
│   ├── stockData.go           # 数据结构定义
│   ├── rawData.go             # 原始数据管理（StocksRaw）
│   ├── loadData.go            # CSV数据加载
│   ├── dealStockData.go       # 数据处理（峰谷点识别、分段）
│   └── defindStock.go         # 点类型常量定义
├── stockStrategy/             # 策略分析
│   ├── types.go               # 策略接口定义
│   ├── strategy.go            # 策略分发器（旧实现）
│   ├── buyHighSellLowStrategy.go  # 策略1新实现（推荐）
│   └── hightPointStrategy.go  # 高点策略
├── tradeTest/                 # 回测框架
│   ├── tradeTest.go           # 回测执行引擎
│   └── buyHighSellLowStrategy_test.go  # 测试用例
└── Data/                      # 数据存储（CSV格式）
    ├── sh.600000_ALL.csv      # 单只股票日线数据
    └── stockList.csv          # 股票列表
```

---

## 二、新架构设计

### 2.1 核心概念分离

```
策略 = 选股器(Selector) + 交易信号生成器(SignalGenerator)
```

**选股器职责**: 从全市场筛选出符合条件的股票代码列表
**信号生成器职责**: 对单只股票的历史数据，逐日判断买入/卖出信号

### 2.2 接口设计

```go
// stockStrategy/interfaces.go

package stockStrategy

import (
    "stock-go/stockData"
)

// ===== 选股器接口 =====
type StockSelector interface {
    // 选择股票代码列表
    // 参数: allCodes - 全市场股票代码
    // 返回: 筛选后的代码列表
    SelectStocks(allCodes []string) []string

    // 获取选股器名称
    GetName() string
}

// ===== 交易信号生成器接口 =====
type SignalGenerator interface {
    // 初始化策略状态(每只股票开始回测前调用)
    Reset()

    // 处理单日数据,返回交易信号
    // 参数:
    //   - dayData: 当天的K线数据
    //   - dateIndex: 数据索引(从0开始)
    //   - position: 当前持仓状态(nil表示空仓)
    // 返回:
    //   - signal: 1=买入, -1=卖出, 0=无操作
    ProcessDay(dayData *stockData.StockDataDay, dateIndex int, position *Position) int

    // 获取信号生成器名称
    GetName() string
}

// ===== 完整策略接口 =====
type Strategy interface {
    // 获取选股器
    GetSelector() StockSelector

    // 获取信号生成器
    GetSignalGenerator() SignalGenerator

    // 获取策略名称
    GetName() string
}

// ===== 持仓状态 =====
type Position struct {
    StockCode   string
    StockName   string
    StockNum    int      // 持有股数
    BuyPrice    float32  // 买入价格
    BuyDate     string   // 买入日期
    BuyIndex    int      // 买入时的数据索引
    HoldDays    int      // 持有天数
}
```

---

## 三、回测流程设计

### 3.1 回测主流程

```go
// tradeTest/backtestEngine.go

package tradeTest

import (
    "fmt"
    "stock-go/globalDefine"
    "stock-go/stockData"
    "stock-go/stockStrategy"
)

type BacktestEngine struct {
    initialCash float64
    strategy    stockStrategy.Strategy
}

func NewBacktestEngine(initialCash float64, strategy stockStrategy.Strategy) *BacktestEngine {
    return &BacktestEngine{
        initialCash: initialCash,
        strategy:    strategy,
    }
}

// 执行回测
func (engine *BacktestEngine) Run() BacktestResult {
    // 第一步: 选股
    allCodes := getAllStockCodes()
    selectedCodes := engine.strategy.GetSelector().SelectStocks(allCodes)

    fmt.Printf("策略[%s]选股结果: %d只股票\n",
        engine.strategy.GetName(), len(selectedCodes))

    // 第二步: 对每只股票进行回测
    wallet := initWallet(engine.initialCash)
    allRecords := make(map[string][]globalDefine.OperateRecord)

    for _, code := range selectedCodes {
        records := engine.backtestSingleStock(code, &wallet)
        if len(records) > 0 {
            allRecords[code] = records
        }
    }

    // 第三步: 计算绩效
    return calculatePerformance(wallet, allRecords)
}

// 单只股票回测
func (engine *BacktestEngine) backtestSingleStock(
    code string,
    wallet *globalDefine.Wallet,
) []globalDefine.OperateRecord {
    // 1. 加载原始数据
    stockInfo := stockData.GetStockRawBycode(code)
    if stockInfo == nil || len(stockInfo.Datas.DayDatas) == 0 {
        return nil
    }

    dayDatas := stockInfo.Datas.DayDatas
    signalGen := engine.strategy.GetSignalGenerator()

    // 2. 重置策略状态
    signalGen.Reset()

    // 3. 逐日循环
    var position *stockStrategy.Position = nil
    var records []globalDefine.OperateRecord

    for i := 0; i < len(dayDatas); i++ {
        dayData := &dayDatas[i]

        // 4. 获取交易信号
        signal := signalGen.ProcessDay(dayData, i, position)

        // 5. 执行交易
        if signal == 1 && position == nil { // 买入信号且当前空仓
            position = engine.executeBuy(code, stockInfo.Name, dayData, i, wallet)
            if position != nil {
                records = append(records, globalDefine.OperateRecord{
                    StockCode:  code,
                    StockName:  stockInfo.Name,
                    BuyOperate: createBuyOperate(position, dayData),
                    Status:     1, // 已买入
                })
            }
        } else if signal == -1 && position != nil { // 卖出信号且当前持仓
            record := &records[len(records)-1]
            engine.executeSell(position, dayData, wallet, record)
            position = nil // 清空持仓
        }

        // 6. 更新持有天数
        if position != nil {
            position.HoldDays++
        }
    }

    // 7. 强制平仓未卖出的持仓(使用最后一天价格)
    if position != nil {
        lastDay := &dayDatas[len(dayDatas)-1]
        record := &records[len(records)-1]
        engine.executeSell(position, lastDay, wallet, record)
    }

    return records
}

// 执行买入
func (engine *BacktestEngine) executeBuy(
    code, name string,
    dayData *stockData.StockDataDay,
    dateIndex int,
    wallet *globalDefine.Wallet,
) *stockStrategy.Position {
    price := float64(dayData.PriceA)

    // 计算可买股数(假设每次使用10%的现金)
    cashToUse := wallet.Cash * 0.1
    stockNum := int(cashToUse / price / 100) * 100 // 整手买入

    if stockNum < 100 {
        return nil // 资金不足
    }

    actualCost := price * float64(stockNum)
    wallet.Cash -= actualCost

    return &stockStrategy.Position{
        StockCode: code,
        StockName: name,
        StockNum:  stockNum,
        BuyPrice:  float32(price),
        BuyDate:   dayData.DataStr,
        BuyIndex:  dateIndex,
        HoldDays:  0,
    }
}

// 执行卖出
func (engine *BacktestEngine) executeSell(
    position *stockStrategy.Position,
    dayData *stockData.StockDataDay,
    wallet *globalDefine.Wallet,
    record *globalDefine.OperateRecord,
) {
    sellPrice := float64(dayData.PriceA)
    sellAmount := sellPrice * float64(position.StockNum)

    wallet.Cash += sellAmount

    // 更新操作记录
    record.SellOperate = globalDefine.Operate{
        OperateType: 2,
        SellPrice:   sellPrice,
        OperateDate: dayData.DataStr,
        StockCode:   position.StockCode,
        StockName:   position.StockName,
        StockNum:    position.StockNum,
    }
    record.Status = 2 // 已卖出
    record.Profit = (sellPrice - float64(position.BuyPrice)) * float64(position.StockNum)
}
```

### 3.2 回测流程图

```
开始
  ↓
第一步: 调用选股器获取股票代码列表
  ↓
第二步: 从StocksRaw加载每只股票的原始数据
  ↓
第三步: 对每只股票执行回测
  ├─ 3.1 重置信号生成器状态
  ├─ 3.2 逐日循环
  │   ├─ 调用ProcessDay()获取交易信号
  │   ├─ 信号=1且空仓 → 执行买入
  │   ├─ 信号=-1且持仓 → 执行卖出
  │   └─ 更新持有天数
  └─ 3.3 强制平仓未卖出持仓
  ↓
第四步: 计算组合绩效指标
  ↓
返回回测结果
```

---

## 四、具体策略实现示例

### 4.1 策略1: 追涨杀跌策略

#### 4.1.1 选股器实现

```go
// stockStrategy/selectors/allMarketSelector.go

package selectors

// ===== 全市场选股 =====
type AllMarketSelector struct{}

func NewAllMarketSelector() *AllMarketSelector {
    return &AllMarketSelector{}
}

func (s *AllMarketSelector) SelectStocks(allCodes []string) []string {
    return allCodes // 返回所有股票
}

func (s *AllMarketSelector) GetName() string {
    return "全市场"
}
```

```go
// stockStrategy/selectors/highPointSelector.go

package selectors

import (
    "fmt"
    "stock-go/stockData"
)

// ===== 高点选股 =====
type HighPointSelector struct {
    LookbackDays int // 回看天数,默认500
    RecentDays   int // 最近N天内出现高点,默认15
}

func NewHighPointSelector(lookbackDays, recentDays int) *HighPointSelector {
    return &HighPointSelector{
        LookbackDays: lookbackDays,
        RecentDays:   recentDays,
    }
}

func (s *HighPointSelector) SelectStocks(allCodes []string) []string {
    var selected []string

    for _, code := range allCodes {
        stockInfo := stockData.GetStockRawBycode(code)
        if stockInfo == nil {
            continue
        }

        // 检查最近是否出现高点
        if s.isRecentHighPoint(stockInfo) {
            selected = append(selected, code)
        }
    }

    return selected
}

func (s *HighPointSelector) isRecentHighPoint(stock *stockData.StockInfo) bool {
    dayDatas := stock.Datas.DayDatas
    if len(dayDatas) < s.LookbackDays {
        return false
    }

    // 检查最后RecentDays天内是否有新高点
    startIndex := len(dayDatas) - s.LookbackDays
    endIndex := len(dayDatas)
    recentStartIndex := len(dayDatas) - s.RecentDays

    var maxPrice float32 = 0
    var maxIndex int = -1

    for i := startIndex; i < endIndex; i++ {
        if dayDatas[i].PriceA > maxPrice {
            maxPrice = dayDatas[i].PriceA
            maxIndex = i
        }
    }

    // 最高点出现在最近RecentDays天内
    return maxIndex >= recentStartIndex
}

func (s *HighPointSelector) GetName() string {
    return fmt.Sprintf("%d天高点选股(最近%d天)", s.LookbackDays, s.RecentDays)
}
```

#### 4.1.2 信号生成器实现

```go
// stockStrategy/signals/buyHighSellLowSignal.go

package signals

import (
    "fmt"
    "stock-go/stockData"
    "stock-go/stockStrategy"
)

// ===== 追涨杀跌信号生成器 =====
type BuyHighSellLowSignal struct {
    LookbackDays    int     // 回看天数,默认300
    SellDropPercent float64 // 止损百分比,默认0.06
    MaxHoldDays     int     // 最大持有天数,默认15

    // 内部状态(防止未来函数)
    historyPrices []float32 // 历史价格队列
}

func NewBuyHighSellLowSignal(lookbackDays int, sellDropPercent float64, maxHoldDays int) *BuyHighSellLowSignal {
    return &BuyHighSellLowSignal{
        LookbackDays:    lookbackDays,
        SellDropPercent: sellDropPercent,
        MaxHoldDays:     maxHoldDays,
        historyPrices:   make([]float32, 0, 500),
    }
}

func (sg *BuyHighSellLowSignal) Reset() {
    sg.historyPrices = sg.historyPrices[:0] // 清空历史价格
}

func (sg *BuyHighSellLowSignal) ProcessDay(
    dayData *stockData.StockDataDay,
    dateIndex int,
    position *stockStrategy.Position,
) int {
    currentPrice := dayData.PriceA

    // 1. 更新历史价格队列
    sg.historyPrices = append(sg.historyPrices, currentPrice)

    // 2. 数据不足,无操作
    if len(sg.historyPrices) < sg.LookbackDays {
        return 0
    }

    // 3. 判断买入信号(空仓时)
    if position == nil {
        if sg.isBuySignal(currentPrice) {
            return 1 // 买入
        }
        return 0
    }

    // 4. 判断卖出信号(持仓时)
    if sg.isSellSignal(currentPrice, position) {
        return -1 // 卖出
    }

    return 0
}

// 买入信号: 达到历史最高价
func (sg *BuyHighSellLowSignal) isBuySignal(currentPrice float32) bool {
    historyLen := len(sg.historyPrices)
    startIndex := historyLen - sg.LookbackDays

    // 找出回看窗口内的最高价(不包括当前价格)
    var highestPrice float32 = 0
    for i := startIndex; i < historyLen-1; i++ {
        if sg.historyPrices[i] > highestPrice {
            highestPrice = sg.historyPrices[i]
        }
    }

    // 当前价格达到或超过历史最高价(允许0.5%误差)
    return currentPrice >= highestPrice*0.995
}

// 卖出信号: 止损或超过最大持有天数
func (sg *BuyHighSellLowSignal) isSellSignal(currentPrice float32, position *stockStrategy.Position) bool {
    // 条件1: 跌幅止损
    dropPercent := float64(position.BuyPrice-currentPrice) / float64(position.BuyPrice)
    if dropPercent >= sg.SellDropPercent {
        return true
    }

    // 条件2: 超过最大持有天数
    if position.HoldDays >= sg.MaxHoldDays {
        return true
    }

    return false
}

func (sg *BuyHighSellLowSignal) GetName() string {
    return fmt.Sprintf("追涨杀跌(%d天新高,止损%.1f%%,最多持有%d天)",
        sg.LookbackDays, sg.SellDropPercent*100, sg.MaxHoldDays)
}
```

#### 4.1.3 完整策略组合

```go
// stockStrategy/strategies/buyHighSellLowStrategy.go

package strategies

import (
    "fmt"
    "stock-go/stockStrategy"
    "stock-go/stockStrategy/selectors"
    "stock-go/stockStrategy/signals"
)

// ===== 追涨杀跌策略 =====
type BuyHighSellLowStrategy struct {
    selector  stockStrategy.StockSelector
    signalGen stockStrategy.SignalGenerator
}

func NewBuyHighSellLowStrategy() *BuyHighSellLowStrategy {
    return &BuyHighSellLowStrategy{
        selector: selectors.NewHighPointSelector(500, 15),
        signalGen: signals.NewBuyHighSellLowSignal(300, 0.06, 15),
    }
}

func (s *BuyHighSellLowStrategy) GetSelector() stockStrategy.StockSelector {
    return s.selector
}

func (s *BuyHighSellLowStrategy) GetSignalGenerator() stockStrategy.SignalGenerator {
    return s.signalGen
}

func (s *BuyHighSellLowStrategy) GetName() string {
    return fmt.Sprintf("策略1[%s + %s]",
        s.selector.GetName(), s.signalGen.GetName())
}
```

### 4.2 策略2示例: 板块轮动策略

```go
// stockStrategy/selectors/sectorStrengthSelector.go

package selectors

import (
    "sort"
    "stock-go/stockData"
)

// ===== 板块强势选股 =====
type SectorStrengthSelector struct {
    SectorCode   string  // 板块代码
    TopN         int     // 选择板块内涨幅前N名
    LookbackDays int     // 涨幅统计天数
}

func NewSectorStrengthSelector(sectorCode string, topN, lookbackDays int) *SectorStrengthSelector {
    return &SectorStrengthSelector{
        SectorCode:   sectorCode,
        TopN:         topN,
        LookbackDays: lookbackDays,
    }
}

func (s *SectorStrengthSelector) SelectStocks(allCodes []string) []string {
    // 1. 筛选出该板块的股票
    sectorStocks := s.filterBySector(allCodes, s.SectorCode)

    // 2. 计算每只股票的涨幅
    type StockGain struct {
        Code string
        Gain float64
    }
    var gains []StockGain

    for _, code := range sectorStocks {
        gain := s.calculateGain(code, s.LookbackDays)
        gains = append(gains, StockGain{Code: code, Gain: gain})
    }

    // 3. 按涨幅排序,取前N名
    sort.Slice(gains, func(i, j int) bool {
        return gains[i].Gain > gains[j].Gain
    })

    var selected []string
    for i := 0; i < min(s.TopN, len(gains)); i++ {
        selected = append(selected, gains[i].Code)
    }

    return selected
}

func (s *SectorStrengthSelector) filterBySector(allCodes []string, sectorCode string) []string {
    // TODO: 根据板块代码筛选股票
    return allCodes
}

func (s *SectorStrengthSelector) calculateGain(code string, lookbackDays int) float64 {
    stockInfo := stockData.GetStockRawBycode(code)
    if stockInfo == nil || len(stockInfo.Datas.DayDatas) < lookbackDays {
        return 0
    }

    dayDatas := stockInfo.Datas.DayDatas
    startPrice := dayDatas[len(dayDatas)-lookbackDays].PriceA
    endPrice := dayDatas[len(dayDatas)-1].PriceA

    return float64(endPrice-startPrice) / float64(startPrice)
}

func (s *SectorStrengthSelector) GetName() string {
    return "板块强势选股"
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```go
// stockStrategy/signals/breakthroughSignal.go

package signals

import (
    "stock-go/stockData"
    "stock-go/stockStrategy"
)

// ===== 突破买入 + 跌破均线卖出 =====
type BreakthroughSignal struct {
    MADays      int     // 均线天数
    BreakRatio  float64 // 突破幅度

    maPrices []float32 // MA价格队列
}

func NewBreakthroughSignal(maDays int, breakRatio float64) *BreakthroughSignal {
    return &BreakthroughSignal{
        MADays:     maDays,
        BreakRatio: breakRatio,
        maPrices:   make([]float32, 0, 500),
    }
}

func (sg *BreakthroughSignal) Reset() {
    sg.maPrices = sg.maPrices[:0]
}

func (sg *BreakthroughSignal) ProcessDay(
    dayData *stockData.StockDataDay,
    dateIndex int,
    position *stockStrategy.Position,
) int {
    currentPrice := dayData.PriceA
    sg.maPrices = append(sg.maPrices, currentPrice)

    // 计算MA
    ma := sg.calculateMA()
    if ma == 0 {
        return 0 // 数据不足
    }

    if position == nil {
        // 买入信号: 价格突破MA一定比例
        if float64(currentPrice) > ma*(1+sg.BreakRatio) {
            return 1
        }
    } else {
        // 卖出信号: 价格跌破MA
        if float64(currentPrice) < ma {
            return -1
        }
    }

    return 0
}

func (sg *BreakthroughSignal) calculateMA() float64 {
    if len(sg.maPrices) < sg.MADays {
        return 0
    }

    startIndex := len(sg.maPrices) - sg.MADays
    var sum float32 = 0
    for i := startIndex; i < len(sg.maPrices); i++ {
        sum += sg.maPrices[i]
    }

    return float64(sum) / float64(sg.MADays)
}

func (sg *BreakthroughSignal) GetName() string {
    return "突破信号"
}
```

---

## 五、使用方式

### 5.1 基本使用

```go
// main.go 或测试文件

package main

import (
    "fmt"
    "stock-go/stockStrategy/strategies"
    "stock-go/tradeTest"
)

func main() {
    // 方式1: 使用预定义策略1
    strategy1 := strategies.NewBuyHighSellLowStrategy()
    engine := tradeTest.NewBacktestEngine(1000000, strategy1)
    result := engine.Run()
    fmt.Printf("回测结果:\n%+v\n", result)
}
```

### 5.2 自定义组合使用

```go
// 方式2: 自定义选股器和信号生成器组合
package main

import (
    "stock-go/stockStrategy"
    "stock-go/stockStrategy/selectors"
    "stock-go/stockStrategy/signals"
    "stock-go/tradeTest"
)

type CustomStrategy struct {
    selector  stockStrategy.StockSelector
    signalGen stockStrategy.SignalGenerator
}

func (s *CustomStrategy) GetSelector() stockStrategy.StockSelector {
    return s.selector
}

func (s *CustomStrategy) GetSignalGenerator() stockStrategy.SignalGenerator {
    return s.signalGen
}

func (s *CustomStrategy) GetName() string {
    return "自定义策略"
}

func main() {
    customStrategy := &CustomStrategy{
        selector: selectors.NewHighPointSelector(300, 10),
        signalGen: signals.NewBuyHighSellLowSignal(200, 0.08, 20),
    }

    engine := tradeTest.NewBacktestEngine(1000000, customStrategy)
    result := engine.Run()
}
```

---

## 六、优势总结

✅ **职责清晰**: 选股和交易信号完全分离
✅ **避免未来函数**: 信号生成器通过内部状态维护历史数据
✅ **易于扩展**: 新增策略只需实现Selector和SignalGenerator接口
✅ **灵活组合**: 不同的选股器和信号生成器可以自由组合
✅ **统一回测**: 所有策略使用同一个BacktestEngine
✅ **状态隔离**: 每只股票回测前调用Reset()，确保状态独立

---

## 七、新文件结构

```
/home/beven/gits/stock-go/
├── stockStrategy/
│   ├── interfaces.go                    # 新增：接口定义
│   ├── selectors/                       # 新增：选股器目录
│   │   ├── allMarketSelector.go         # 全市场选股
│   │   ├── highPointSelector.go         # 高点选股
│   │   └── sectorStrengthSelector.go    # 板块强势选股
│   ├── signals/                         # 新增：信号生成器目录
│   │   ├── buyHighSellLowSignal.go      # 追涨杀跌信号
│   │   └── breakthroughSignal.go        # 突破信号
│   ├── strategies/                      # 新增：完整策略目录
│   │   └── buyHighSellLowStrategy.go    # 策略1实现
│   ├── types.go                         # 保留：旧接口定义
│   ├── strategy.go                      # 待废弃：旧实现
│   ├── buyHighSellLowStrategy.go        # 待废弃：旧策略1
│   └── hightPointStrategy.go            # 保留：高点策略函数
├── tradeTest/
│   ├── backtestEngine.go                # 新增：新回测引擎
│   ├── tradeTest.go                     # 保留：旧回测引擎
│   └── buyHighSellLowStrategy_test.go   # 待更新：测试用例
└── 回测优化.md                           # 本文档
```

---

## 八、实施步骤

### 阶段1: 创建新接口和基础结构
- [ ] 创建 `stockStrategy/interfaces.go`
- [ ] 创建 `stockStrategy/selectors/` 目录
- [ ] 创建 `stockStrategy/signals/` 目录
- [ ] 创建 `stockStrategy/strategies/` 目录

### 阶段2: 实现选股器
- [ ] 实现 `AllMarketSelector`
- [ ] 实现 `HighPointSelector`

### 阶段3: 实现信号生成器
- [ ] 实现 `BuyHighSellLowSignal`（包含完整的卖出逻辑）

### 阶段4: 实现新回测引擎
- [ ] 创建 `tradeTest/backtestEngine.go`
- [ ] 实现 `BacktestEngine.Run()`
- [ ] 实现 `backtestSingleStock()`
- [ ] 实现 `executeBuy()` 和 `executeSell()`

### 阶段5: 迁移和测试
- [ ] 将策略1迁移到新架构
- [ ] 编写单元测试
- [ ] 对比新旧回测结果
- [ ] 废弃旧代码

### 阶段6: 扩展更多策略
- [ ] 实现板块轮动策略
- [ ] 实现其他自定义策略

---

## 九、关键要点

### 9.1 防止未来函数

**正确做法**:
```go
// 信号生成器内部维护历史数据
type MySignal struct {
    historyPrices []float32
}

func (sg *MySignal) ProcessDay(dayData *stockData.StockDataDay, ...) int {
    // 先添加当前价格到历史
    sg.historyPrices = append(sg.historyPrices, dayData.PriceA)

    // 只使用历史数据做决策（不包括未来数据）
    maxPrice := findMax(sg.historyPrices[:len(sg.historyPrices)-1])

    if dayData.PriceA > maxPrice {
        return 1 // 买入
    }
    return 0
}
```

**错误做法**:
```go
// 错误：直接访问未来数据
func wrongStrategy(code string) {
    dayDatas := getAllDayData(code)

    for i := 0; i < len(dayDatas); i++ {
        // 错误：查看未来40天数据
        futureBestPrice := findBestPrice(dayDatas[i:i+40])
        // 这在实盘中是不可能的！
    }
}
```

### 9.2 状态隔离

每只股票回测前必须调用 `Reset()`：

```go
for _, code := range selectedCodes {
    signalGen.Reset() // 清空历史状态
    // 开始新股票的回测
}
```

### 9.3 资金管理

当前设计使用简单的固定比例分配（每次10%现金）：

```go
cashToUse := wallet.Cash * 0.1
stockNum := int(cashToUse / price / 100) * 100
```

未来可以扩展为：
- 等权重分配
- 风险平价
- 凯利公式
- 动态仓位管理

---

## 十、后续优化方向

1. **多策略组合**: 同时运行多个策略，进行组合优化
2. **参数优化**: 使用网格搜索、遗传算法优化策略参数
3. **风险管理**: 添加最大回撤控制、波动率目标等
4. **绩效分析**: 增加夏普比率、最大回撤、胜率等指标
5. **并行回测**: 使用goroutine并行处理多只股票
6. **实盘对接**: 将信号生成器对接到实盘交易系统

---

**文档版本**: v1.0
**创建日期**: 2025-11-22
**最后更新**: 2025-11-22
